
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [线程与进程，协程](#线程与进程协程)
	* [通信方式不同](#通信方式不同)
* [多线程的方法](#多线程的方法)
* [线程的生命周期](#线程的生命周期)
* [线程创建](#线程创建)
* [wait(),notifyAll(),notify()](#waitnotifyallnotify)
* [线程安全](#线程安全)
* [乐观锁与悲观锁](#乐观锁与悲观锁)
	* [乐观锁](#乐观锁)
	* [悲观锁](#悲观锁)
	* [乐观锁如何保证线程安全？（面试题）](#乐观锁如何保证线程安全面试题)
* [常见面试题](#常见面试题)
	* [一个线程抛出OOM之后，其他线程会出现什么问题？](#一个线程抛出oom之后其他线程会出现什么问题)

<!-- /code_chunk_output -->
# 线程与进程，协程
- **进程**：是资源调度的基本单位，拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，
- **属于同一个进程的所有线程共享该进程的所有资源**，包括文件描述符。而不同过的进程相互独立。
- **线程**：是cpu调度的最小单元，又称**轻量级线程**，拥有独立的堆栈空间，计数器，局部变量，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小
- **协程**：协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。（个人表示用的比较少）
## 通信方式不同
- 进程间通信：管道，信号，消息队列，套接字等
- 线程间通信：由于共享数据段所以通信机制很方便

# 多线程的方法
Java里面_所有的线程对象都必须是Thread类或者其子类的实例_
  - 继承Thread类：不可抛异常，不能有返回值
  - 实现Runnable接口：不可抛异常，不能有返回值
  - 实现Callable接口，call()方法为线程执行体，可抛出异常，可有返回值。
    - Future和Callable基本是成对出现的，Callable负责产生结果，Future负责获取结果。  

# 线程的生命周期
  - new：线程新建，单未运行
  - runnable：线程准备就绪，或运行中
  - blocked：阻塞
      - 调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。
      - 调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool)，释放同步锁使线程回到可运行状态（Runnable）
      - 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。
  - waiting：线程进入等待状态，需要等待其他线程的notify才能返回到运行状态
  - time_waiting：超时等待
  - terminated：终止状态

# 线程创建  
线程创建需要委托父线程进行空间分配，子线程继承父线程的ClassLoader，优先级等等，同时分配一个唯一的线程ID标识这个线程对象，在堆内存中等待运行。

# wait(),notifyAll(),notify()
  - 使用wait()、notify()和notifyAll()时需要先对调用对象加锁。
  - 调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。
  - notify()或 notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从 wait()返回。
  - notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为 BLOCKED。
  - 从wait()方法返回的前提是获得了调用对象的锁。

# 线程安全
线程是不拥有资源的，进程是拥有资源的。而线程是由进程创建的，一个进程可以创建多个线程，这些线程共享着进程中的资源。所以，当线程一起并发运行时，同时对一个数据进行修改，就可能会造成数据的不一致性，存在线程不安全的情况。  
1.锁机制  
2.线程安全的集合类  
3.让线程拥有资源ThreadLocal

# 乐观锁与悲观锁
## 乐观锁
每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。

## 悲观锁
总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。

## 乐观锁如何保证线程安全？（面试题）
java中通过CAS算法保证乐观锁的数据安全性，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被阻塞挂起，而是被告知这次竞争中失败，并可以再次尝试。_**乐观是一种思想**_
一般借助volatile关键字来实现共享变量的可见性
- CAS的缺点
  - 1.ABA问题
  - 2.循环时间长开销大
  - 3.只能保证一个共享变量的原子操作

# 常见面试题
## 一个线程抛出OOM之后，其他线程会出现什么问题？
**答**：会继续运行，这个代码测试过，一个线程抛出OOM之后，所占的内**存资源会立即被释放掉** ，从而不会影响其他线程的正常运行。
