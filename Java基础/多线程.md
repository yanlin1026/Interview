<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [1.多线程的方法](#1多线程的方法)
- [2.线程的生命周期](#2线程的生命周期)
- [3.线程创建](#3线程创建)
- [4.wait(),notifyAll(),notify()](#4waitnotifyallnotify)
- [5 线程安全](#5-线程安全)

<!-- /TOC -->
# 1.多线程的方法
Java里面_所有的线程对象都必须是Thread类或者其子类的实例_
  - 继承Thread类：不可抛异常，不能有返回值
  - 实现Runnable接口：不可抛异常，不能有返回值
  - 实现Callable接口，call()方法为线程执行体，可抛出异常，可有返回值。
    - Future和Callable基本是成对出现的，Callable负责产生结果，Future负责获取结果。  

# 2.线程的生命周期
  - new：线程新建，单未运行
  - runnable：线程准备就绪，或运行中
  - blocked：阻塞
      - 调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。
      - 调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool)，释放同步锁使线程回到可运行状态（Runnable）
      - 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。
  - waiting：线程进入等待状态，需要等待其他线程的notify才能返回到运行状态
  - time_waiting：超时等待
  - terminated：终止状态

# 3.线程创建  
线程创建需要委托父线程进行空间分配，子线程继承父线程的ClassLoader，优先级等等，同时分配一个唯一的线程ID标识这个线程对象，在堆内存中等待运行。

# 4.wait(),notifyAll(),notify()
  - 使用wait()、notify()和notifyAll()时需要先对调用对象加锁。
  - 调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。
  - notify()或 notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从 wait()返回。
  - notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为 BLOCKED。
  - 从wait()方法返回的前提是获得了调用对象的锁。

# 5 线程安全
线程是不拥有资源的，进程是拥有资源的。而线程是由进程创建的，一个进程可以创建多个线程，这些线程共享着进程中的资源。所以，当线程一起并发运行时，同时对一个数据进行修改，就可能会造成数据的不一致性，存在线程不安全的情况。  
1.锁机制  
2.线程安全的集合类  
3.让线程拥有资源ThreadLocal
