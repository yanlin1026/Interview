<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [如何理解面向对象？什么是面向对象设计？SOLID原则？](#如何理解面向对象什么是面向对象设计solid原则)
	* [理解对象的概念](#理解对象的概念)
	* [从三大特性解释](#从三大特性解释)
	* [类与类之间的关系](#类与类之间的关系)
	* [项目中哪些体现了这些原则](#项目中哪些体现了这些原则)
* [领域建模解决了什么样的问题？微服务？为什么要用？](#领域建模解决了什么样的问题微服务为什么要用)
* [多线程？线程池？多线程的创建为什么消耗资源，哪里消耗资源？线程池好处是什么？](#多线程线程池多线程的创建为什么消耗资源哪里消耗资源线程池好处是什么)
	* [系统设计复杂](#系统设计复杂)
	* [时间消耗：](#时间消耗)
	* [资源消耗](#资源消耗)
	* [线程池](#线程池)
* [mysql问题，了解到什么程度？索引？事务？乐观锁悲观锁？](#mysql问题了解到什么程度索引事务乐观锁悲观锁)
	* [索引](#索引)
		* [优点：](#优点)
		* [使用：](#使用)
	* [事务](#事务)
* [项目的难度在哪？](#项目的难度在哪)
* [为什么要使用flink？为什么不能一条一条处理写入数据库，然后使用查询时进行count，而要采用流计算？](#为什么要使用flink为什么不能一条一条处理写入数据库然后使用查询时进行count而要采用流计算)
* [挑战是什么？](#挑战是什么)
* [成就感？](#成就感)

<!-- /code_chunk_output -->

# 如何理解面向对象？什么是面向对象设计？SOLID原则？
## 理解对象的概念  
广义：在内存上一段有意义的区域，称作为一个对象。  
 “对象”一般是指类在内存中装载的实例，具有相关的成员变量和成员函数（也称为：方法）。  
“类”:是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，
占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。
## 从三大特性解释
- 继承：子类可以继承父类的成员变量和成员方法。 继承可以提高代码的复用性
	- 子类只能继承父类的非私有成员变量和方法。
	- 单一继承
- 封装：属性的封装和方法的封装
- 多态：
	- 运行时多态：方法的重载
	- 编译时多态：方法的重写
## 类与类之间的关系
- [SOLID原则](https://www.cnblogs.com/OceanEyes/p/overview-of-solid-principles.html) [参考1](https://blog.csdn.net/YegodYue/article/details/66887047)
	- 单一职责：让一个类的职责竟可能的单一，这是个理想状态，很难做到
  - 开放封闭：对扩展开放，对修改封闭，很抽象，不易理解。
  - 里式代换：所有基类出现的地方都可以用派生类替换而不会程序产生错误。子类可以扩展父类的功能，
    但不能改变父类原有的功能。例如机动车必须有轮胎和发动机，子类宝马和奔驰不应该改写没轮胎或者没发动机。
  - 接口隔离：类不应该依赖不需要的接口，知道越少越好。例如电话接口只约束接电话和挂电话，不需要让依赖者知道还有通讯录。
  - 依赖倒置：高层模块不能依赖底层模块
## 项目中哪些体现了这些原则
----
# 领域建模解决了什么样的问题？微服务？为什么要用？  
- DDD  
	- 领域模型是对领域内的概念类或现实世界中对象的可视化表示。又称概念模型、领域对象模型、分析对象模型。
	- 它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。  
	- **六边形架构**；外部所有的服务请求都通过适配层adapter进行访问，各个服务（领域）之间相互隔离，
	- 数据传输会通过特殊的数据传输对象（DTO）传输给表现层，adapter就负责对数据进行转换协调各个服务之间的相互调用访问
- 微服务与SOA
    - 微服务：
    - SOA：面向服务的架构
----
# 多线程？线程池？多线程的创建为什么消耗资源，哪里消耗资源？线程池好处是什么？
## 系统设计复杂  
- 多线程程序在访问共享数据的时候往往需要我们很小心的处理,否则就会出现难以发现的BUG，
- 一般地，多线程程序往往比单线程程序设计会更加复杂（尽管有些单线程处理程序可能比多线程程序要复杂），
而且错误很难重现（因为线程调度的无序性，某些bug的出现依赖于某种特定的线程执行时序）。
## 时间消耗：
  - 线程创建开销：包括内存分配耗时，线程对象创建耗时  
  - 上下文切换开销：当前任务执行一个时间片后会切换到下一个任务。在切换之前，上一个任务的状态会被保存下来，下次切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换。

## 资源消耗  
  - 内存同步的开销（线程需要一些内存在维持线程本地栈,每个线程都有本地独立的栈用以存储线程专用数据）
      - 编译器和CPU为了优化程序的性能（在编译阶段）， 对指令序列进行重新排序的一种手段，编译器和CPU对指令做重排序操作，但是共享变量的访问往往采用synchronized和volatile提供的可见性保证共享变量的访问安全性，即内存栅栏禁止指令重排序，这无疑是降低了CPU和编译器的执行效率
      - 锁竞争时：竞争失败的的线程进入阻塞状态，JVM通过**自旋等待**的方式，直到获取锁为止，或者直接**挂起等待线程**
  - 大量的线程在竞争CPU资源时还将产生性能的开销
  - 大量空闲的线程会占用许多内存，给垃圾回收器带来压力
	- 降低程序的稳定性，OutOfMemoryError等等
## 线程池
- 优势：
    - 降低资源消耗：重复利用已创建的线程执行任务，降低频繁创建销毁线程的开销
    - 提高速度：任务到达时会立即执行
    - 线程管理：统一分配，调优监控
- 问题：饥饿死锁：线程池中的某些任务需要等待其他任务结束才能执行
- 执行任务的流程：
    - 正在执行任务数小于corePoolSize，直接创建执行任务
    - 若大于，将任务放在workQueue中，
        - ArrayBlockingQueue：一个有界的阻塞队列，数组实现，大小不可变
        - LinkedBlockingQueue：内部以一个链表对其元素进行存储，可自定义上限，默认为Integer.MAX_VALUE作为上限
        - SynchronousQueue：一个特殊的队列，只能够容纳单个元素
        - PriorityBlockingQueue：一个具有优先级的无限阻塞队列。实现Comparable接口修改优先级
    - 若workQueue已满，并且小于maximumPoolSize，创建线程执行任务
    - 如果超出maximumPoolSize，执行拒绝策略：简单点：1.抛异常 2.直接丢 3.丢掉最前的 4.调用线程处理
        - AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
        - DiscardPolicy：也是丢弃任务，但是不抛出异常。
        - DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
        - CallerRunsPolicy：由调用线程处理该任务
----
# mysql问题，了解到什么程度？索引？事务？乐观锁悲观锁？
##索引  
数据库中排序的数据结构，协助快速查询，更新的操作，数据的实现一般是B树或者B+树
- 增加数据库的物理存储空间
- 插入和修改数据时要花费较多的时间（索引的位置也要变动）
- 维护索引需要耗费时间，随着数据量的增加而增加  
### 优点：
- 唯一索引可以保证数据的唯一性
- 查询速度加快
- 在查询中使用索引，可以提高性能  
### 使用：
- 在经常需要搜索的列上，加快检索速度
- 主键确保唯一性
- 需要排序的字段上简历索引
## 事务  

# 项目的难度在哪？

# 为什么要使用flink？为什么不能一条一条处理写入数据库，然后使用查询时进行count，而要采用流计算？
# 挑战是什么？

# 成就感？
