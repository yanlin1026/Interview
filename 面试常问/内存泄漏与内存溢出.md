- **内存泄漏**：也叫OOM，分配出去的内存无法回收（不再使用的对象或者变量仍占内存空间），在Java中内存泄漏就是存在一些被分配的对象（可达的，却是无用的）无法被gc回收。
- **内存溢出**：<font color=#FF0000 >程序要求的内存超出了系统所能分配的范围</font>（比如：栈满还入栈，出现上溢；栈空还出栈，出现下溢）
# 内存泄漏
- Java判断内存空间是否符合垃圾回收标准有两个:
1. 给对象赋予了空值null，以下再没有调用过。    
2. 给对象赋予了新值，既重新分配了内存空间。

GC可以有效的解决第一种情况，但是无法保证情况二，所以Java存在的内存泄漏主要是第二种

- 内存泄露的几种场景：
1. 长生命周期的对象持有短生命周期对象的引用，即静态集合类。
2. 变量不合理的作用域。
3. 没有及时的将对象设置为null
4. 各种连接没显示关闭。数据库连接、网络连接、IO连接，没显示的close，会造成很多对象无法回收。
5. 监听器。释放对象时没有删除监听器。

- 避免内存泄漏
1. 尽早释放无用对象的引用
2. 使用字符串处理，避免使用String，应大量使用StringBuffer，每一个String对象都得独立占用内存一块区域
3. 尽量少用静态变量，因为静态变量存放在永久代（方法区）
4. 避免在循环中创建对象
5. 开启大型文件或从数据库一次拿了太多的数据很容易造成内存溢出，所以在这些地方要大概计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值。
# 内存溢出
无法申请到足够的空间
**堆内存溢出**：内存的申请过程如下
1. jvm先尝试在eden区分配新建对象所需的内存；如果内存大小足够，申请结束，否则下一步
2. jvm启动新生代GC，试图将eden区中不活跃的对象释放掉，释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区；
3. Survivor区被用来作为Eden及old的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区；
4. 当OLD区空间不够时，JVM会在OLD区进行full GC；
5. full GC后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”
